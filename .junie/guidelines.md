# Rust Gallery Development Guidelines

## Project Overview
The Rust Gallery (rusty-images) is a high-performance image gallery application built with:
- **Backend**: Rust with Rocket web framework (v0.5.1)
- **Frontend**: React/TypeScript with Tailwind CSS
- **Database**: SQLite with Diesel ORM
- **Caching**: Moka in-memory cache for image processing
- **Architecture**: Full-stack application with REST API and static file serving

## Build & Configuration Instructions

### Prerequisites
- Rust 2024 edition (specified in Cargo.toml)
- Node.js and pnpm (for UI development)
- SQLite3

### Backend Setup
1. **Database Setup**:
   ```bash
   make db-setup  # Initialize database with migrations
   ```
   - Database file: `db/db.sqlite`
   - Migrations are automatically run on application startup
   - Pool size: 20 connections, 60s timeout

2. **Development Mode**:
   ```bash
   make dev  # Hot reloading with cargo-watch
   ```
   - Installs cargo-watch if not present
   - Uses RUST_LOG=info by default

3. **Production Build**:
   ```bash
   make build     # Release build
   make run       # Run in release mode
   make release   # Full release pipeline (clean, test, build)
   ```

### Frontend Setup
Located in `src-ui/` directory:
1. **Dependencies**:
   ```bash
   cd src-ui
   pnpm install
   ```

2. **Development**:
   ```bash
   pnpm start  # Development server
   ```

3. **Production Build**:
   ```bash
   pnpm run build  # Builds to ../static directory
   ```

### Configuration Files
- **Rocket.toml**: Web server configuration
  - Port: 8000, Workers: 8
  - Image directories: `["files", "captions", "zishy", "sc"]`
  - Upload limits: JSON (10 MiB), file/jpg (10 MiB)
- **Cargo.toml**: Rust dependencies and project metadata
- **package.json**: UI dependencies and build scripts

### Docker Support
```bash
make docker-build    # Build image
make docker-run      # Run container (port 8000, volume mount ./images:/build/images)
make docker-deploy   # Build and push to registry
```

## Testing Information

### Backend Testing
The project uses Rocket's testing framework with blocking clients for integration tests.

#### Test Structure
- Test files: `src/tests.rs` (currently commented out), `src/simple_test.rs`
- Test command: `cargo test` or `make test`
- Database synchronization: Uses `parking_lot::Mutex` for test isolation

#### Example Test Pattern
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use rocket::local::blocking::Client;
    use rocket::http::Status;

    #[test]
    fn test_endpoint() {
        let client = Client::tracked(crate::rocket()).expect("valid rocket instance");
        let response = client.get("/endpoint").dispatch();
        assert_eq!(response.status(), Status::Ok);
    }
}
```

#### Running Tests
```bash
cargo test                    # Run all tests
cargo test -- --test-threads=1  # Run tests sequentially (for DB tests)
make test                     # Via Makefile
```

#### Adding New Tests
1. Create test functions with `#[test]` attribute
2. Use `rocket::local::blocking::Client` for HTTP testing
3. Include `#[cfg(test)]` for test-only modules
4. Add test module to main.rs with `#[cfg(test)] mod your_test;`

### Frontend Testing
Located in `src-ui/`:
- Framework: Jest with React Testing Library
- Command: `pnpm test`
- Configuration: ESLint with react-app rules

## Development Practices

### Code Style & Formatting
- **Rust**: Uses standard rustfmt (no custom configuration)
  ```bash
  make format  # Format all Rust code
  cargo fmt    # Direct formatting
  ```
- **TypeScript/React**: Prettier configuration in `src-ui/.prettierrc.json`
  ```bash
  cd src-ui && prettier --write .
  ```

### Project Structure Conventions
```
src/
├── main.rs              # Application entry point with Rocket setup
├── cache_files.rs       # Image caching logic
├── error.rs            # Custom error types and handling
├── models/             # Database models and repositories
│   └── file/           # File model with repository pattern
├── handlers/           # HTTP request handlers organized by domain
│   ├── files/          # File operations (download, thumbnails)
│   ├── folders/        # Folder management
│   ├── tags/           # Tagging system
│   ├── configs/        # Configuration management
│   └── tasks/          # Background task management
└── tests.rs           # Test modules
```

### Database Patterns
- **Migrations**: Diesel migrations in `migrations/` directory
- **Models**: Repository pattern in `src/models/`
- **Schema**: Auto-generated by Diesel
- **Connection**: Managed connection pools via Rocket

### Image Processing
- **Library**: `image` crate for resizing and format conversion
- **Caching**: Moka cache with 4-day TTL (345600 seconds)
- **Formats**: JPEG output for thumbnails, original format preservation
- **Resize**: Lanczos3 filter for quality

### Error Handling
- **Custom Types**: `AppError` enum in `src/error.rs`
- **HTTP Responses**: Proper status codes and JSON error responses
- **Result Types**: `AppResult<T>` alias for consistent error handling

### API Design
- **REST endpoints**: Organized by domain (`/files`, `/folders`, `/tags`, `/config`)
- **CORS**: Enabled for all origins in development
- **Content Types**: JSON API with multipart support for uploads
- **Static Files**: Served from `static/` directory

### Performance Considerations
- **Release Profile**: Optimized with `opt-level = 3`
- **Connection Pooling**: 20 database connections
- **Image Caching**: In-memory cache for processed images
- **Background Tasks**: ThreadManager for non-blocking operations

### Utility Commands
```bash
make help        # Show all available commands
make version     # Show project and toolchain versions
make update      # Update Rust dependencies
make clean       # Clean build artifacts
```

## Debugging Tips
1. **Database Issues**: Check `db/db.sqlite` exists and migrations ran
2. **Image Processing**: Verify image directories in Rocket.toml exist
3. **CORS Issues**: Check frontend origin matches CORS configuration
4. **Build Failures**: Ensure Rust 2024 edition compatibility
5. **UI Build**: Verify pnpm is used (not npm) for frontend dependencies